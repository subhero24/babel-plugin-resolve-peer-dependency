import Path from"path";import Resolve from"resolve-from";import Filesystem from"fs";const transform=(plugin,dependency)=>{if(plugin.cwd===process.cwd())return dependency;{let packageFilename=Path.join(plugin.cwd,"package.json");if(Filesystem.existsSync(packageFilename)){let packageJSON=require(packageFilename),peerDependencies=packageJSON.peerDependencies||{};for(let peerDependency in peerDependencies)if(dependency===peerDependency||dependency.startsWith(peerDependency+"/")){let localDependency=Resolve.silent(process.cwd(),dependency);if(null==localDependency)return console.warn(`Peerdependency '${peerDependency}' was not found in main package. '${dependency}' will not be resolved.`),dependency;{let relativeRoot=Path.relative(plugin.cwd,process.cwd()),relativeLocalDependency=Path.relative(process.cwd(),localDependency),relativeDependency=Path.join(relativeRoot,relativeLocalDependency);return console.log(`The dependency '${dependency}' was specified as a peerDependency in ${packageJSON.name}. Transforming it to ${relativeDependency} to use package '${dependency}' from the project in the current working directory`),relativeDependency}}}return dependency}};export default({types:types})=>{const traverseExpression=(type,arg)=>type.isStringLiteral(arg)?arg:type.isBinaryExpression(arg)?traverseExpression(type,arg.left):null,visitor={CallExpression(path){if("require"===path.node.callee.name||"Import"===path.node.callee.type){const args=path.node.arguments;if(!args.length)return;const firstArg=traverseExpression(types,args[0]);firstArg&&(firstArg.value=transform(this,firstArg.value))}},ImportDeclaration(path){path.node.source.value=transform(this,path.node.source.value)},ExportNamedDeclaration(path){path.node.source&&(path.node.source.value=transform(this,path.node.source.value))},ExportAllDeclaration(path){path.node.source&&(path.node.source.value=transform(this,path.node.source.value))}};return{visitor:{Program(path){path.traverse(visitor,this)}}}};
//# sourceMappingURL=index.es.js.map
